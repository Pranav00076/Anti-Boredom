<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brainvita (Peg Solitaire)</title>
    <!-- Load Tailwind CSS from CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game */
        body {
            font-family: 'Inter', sans-serif;
        }
        
        /* Define the out-of-bounds, hole, and peg styles */
        .cell {
            width: 12.5%; /* 100% / 8 (for 7 cells + gaps) approx */
            padding-bottom: 12.5%; /* Creates a square aspect ratio */
            position: relative;
            transition: background-color 0.1s ease-in-out;
        }

        .cell-inner {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* 0: Out-of-bounds */
        .cell-out {
            background-color: transparent;
        }

        /* 1: Empty hole */
        .cell-hole .cell-inner {
            background-color: #374151; /* bg-gray-700 */
            border-radius: 9999px; /* rounded-full */
            cursor: pointer;
            border: 4px solid transparent;
        }

        /* 2: Peg */
        .cell-peg .cell-inner {
            background-color: #374151; /* bg-gray-700 */
            border-radius: 9999px; /* rounded-full */
            padding: 8%;
        }

        .peg {
            width: 100%;
            height: 100%;
            background-color: #fde047; /* bg-yellow-300 */
            border-radius: 9999px; /* rounded-full */
            cursor: pointer;
            border: 2px solid #facc15; /* border-yellow-400 */
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2), 0 1px 2px rgba(255,255,255,0.5);
            transition: all 0.1s ease-in-out;
        }

        .peg:hover {
            transform: scale(1.05);
            filter: brightness(1.1);
        }

        /* UI State Classes */
        .peg.selected {
            background-color: #4ade80; /* bg-green-400 */
            border-color: #22c55e; /* border-green-500 */
            transform: scale(1.1);
            box-shadow: 0 0 15px #4ade80;
        }

        .cell-hole.highlight .cell-inner {
            background-color: #22c55e; /* bg-green-500 */
            border-color: #86efac; /* border-green-300 */
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Simple responsive scaling for the board */
        @media (max-width: 640px) {
            .board-container {
                padding: 1rem;
            }
            .cell {
                width: 13%;
                padding-bottom: 13%;
            }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="game-wrapper w-full max-w-lg">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-4">Brainvita</h1>
        
        <!-- Status Bar -->
        <div class="flex justify-between items-center bg-white p-4 rounded-lg shadow-md mb-4">
            <div class="text-lg">
                Moves: <span id="move-counter" class="font-bold text-blue-600">0</span>
            </div>
            <div class="flex gap-2">
                <button id="undo-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-4 rounded-lg shadow disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    Undo
                </button>
                <button id="reset-btn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg shadow">
                    Reset
                </button>
            </div>
        </div>

        <!-- Game Board -->
        <div class="board-container bg-blue-800 p-2 md:p-4 rounded-lg shadow-xl">
            <div id="game-board" class="grid grid-cols-7 gap-1 md:gap-2">
                <!-- Cells will be generated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Win/Loss Modal -->
    <div id="modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden" role="alertdialog" aria-modal="true" aria-labelledby="modal-title">
        <div class="bg-white rounded-lg shadow-2xl p-8 max-w-sm w-full text-center">
            <h2 id="modal-title" class="text-2xl font-bold mb-4">Game Over!</h2>
            <p id="modal-message" class="text-lg text-gray-700 mb-6">You left 5 pegs.</p>
            <button id="play-again-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg shadow-lg transition-transform transform hover:scale-105">
                Play Again
            </button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- STATE VARIABLES ---
            // 0 = Out-of-bounds, 1 = Empty Hole, 2 = Peg
            const initialBoardState = [
                [0, 0, 2, 2, 2, 0, 0],
                [0, 0, 2, 2, 2, 0, 0],
                [2, 2, 2, 2, 2, 2, 2],
                [2, 2, 2, 1, 2, 2, 2],
                [2, 2, 2, 2, 2, 2, 2],
                [0, 0, 2, 2, 2, 0, 0],
                [0, 0, 2, 2, 2, 0, 0]
            ];
            
            let boardState;
            let moveCounter;
            let selectedPeg = null; // { r, c }
            let undoStack = []; // Stores move objects { from, over, to }

            // --- DOM ELEMENTS ---
            const boardElement = document.getElementById('game-board');
            const moveCounterElement = document.getElementById('move-counter');
            const undoBtn = document.getElementById('undo-btn');
            const resetBtn = document.getElementById('reset-btn');
            const modal = document.getElementById('modal');
            const modalMessage = document.getElementById('modal-message');
            const modalTitle = document.getElementById('modal-title');
            const playAgainBtn = document.getElementById('play-again-btn');

            // --- GAME LOGIC ---

            /**
             * Initializes or resets the game to its starting state.
             */
            function initGame() {
                // Deep copy the initial state to prevent mutation
                boardState = initialBoardState.map(row => [...row]);
                moveCounter = 0;
                selectedPeg = null;
                undoStack = [];
                
                renderBoard();
                updateUI();
                modal.classList.add('hidden');
            }

            /**
             * Renders the entire game board based on the current boardState.
             */
            function renderBoard() {
                boardElement.innerHTML = ''; // Clear the board

                for (let r = 0; r < 7; r++) {
                    for (let c = 0; c < 7; c++) {
                        const cellState = boardState[r][c];
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.r = r;
                        cell.dataset.c = c;
                        
                        let cellType = 'cell-out'; // 0
                        if (cellState === 1) cellType = 'cell-hole';
                        if (cellState === 2) cellType = 'cell-peg';
                        
                        cell.classList.add(cellType);

                        const cellInner = document.createElement('div');
                        cellInner.className = 'cell-inner';

                        if (cellState === 2) {
                            // Add a peg
                            const peg = document.createElement('div');
                            peg.className = 'peg';
                            peg.setAttribute('role', 'button');
                            peg.setAttribute('aria-label', `Peg at row ${r + 1}, col ${c + 1}`);
                            peg.addEventListener('click', (e) => {
                                e.stopPropagation(); // Prevent hole click
                                onPegClick(r, c);
                            });
                            cellInner.appendChild(peg);
                        } else if (cellState === 1) {
                            // Add hole click listener
                            cell.setAttribute('role', 'button');
                            cell.setAttribute('aria-label', `Empty hole at row ${r + 1}, col ${c + 1}`);
                            cell.addEventListener('click', () => onHoleClick(r, c));
                        }

                        cell.appendChild(cellInner);
                        boardElement.appendChild(cell);
                    }
                }
            }

            /**
             * Updates the move counter and Undo button state.
             */
            function updateUI() {
                moveCounterElement.textContent = moveCounter;
                undoBtn.disabled = undoStack.length === 0;
            }

            /**
             * Handles clicking on a peg.
             */
            function onPegClick(r, c) {
                clearHighlights(); // Clear previous selection

                const validMoves = findValidMovesForPeg(r, c);

                if (validMoves.length > 0) {
                    selectedPeg = { r, c };
                    // Highlight selected peg
                    const pegEl = boardElement.querySelector(`[data-r="${r}"][data-c="${c}"] .peg`);
                    if (pegEl) {
                        pegEl.classList.add('selected');
                    }
                    
                    // Highlight valid target holes
                    validMoves.forEach(move => {
                        const holeEl = boardElement.querySelector(`[data-r="${move.to.r}"][data-c="${move.to.c}"]`);
                        if (holeEl) {
                            holeEl.classList.add('highlight');
                        }
                    });
                } else {
                    // Clicked a peg with no moves
                    selectedPeg = null;
                }
            }

            /**
             * Handles clicking on an empty hole.
             */
            function onHoleClick(r, c) {
                if (!selectedPeg) {
                    clearHighlights();
                    return; // No peg is selected
                }

                // Check if this hole is a valid target for the selected peg
                const validMoves = findValidMovesForPeg(selectedPeg.r, selectedPeg.c);
                const move = validMoves.find(m => m.to.r === r && m.to.c === c);

                if (move) {
                    executeMove(move);
                } else {
                    // Clicked an invalid hole, so deselect
                    clearHighlights();
                    selectedPeg = null;
                }
            }

            /**
             * Finds all valid moves for a specific peg.
             * @returns {Array} An array of move objects: { from, over, to }
             */
            function findValidMovesForPeg(r, c) {
                const moves = [];
                const directions = [[-2, 0], [2, 0], [0, -2], [0, 2]]; // [dr, dc]

                for (const [dr, dc] of directions) {
                    const toR = r + dr;
                    const toC = c + dc;
                    const overR = r + dr / 2;
                    const overC = c + dc / 2;

                    // Check if 'to' and 'over' are in bounds
                    if (toR >= 0 && toR < 7 && toC >= 0 && toC < 7 &&
                        boardState[toR][toC] === 1 && // 'to' must be an empty hole
                        boardState[overR][overC] === 2) // 'over' must be a peg
                    {
                        moves.push({
                            from: { r, c },
                            over: { r: overR, c: overC },
                            to: { r: toR, c: toC }
                        });
                    }
                }
                return moves;
            }

            /**
             * Executes a move, updates state, and re-renders.
             */
            function executeMove(move) {
                // Update board state
                boardState[move.from.r][move.from.c] = 1; // Old spot is now a hole
                boardState[move.over.r][move.over.c] = 1; // Jumped peg is removed
                boardState[move.to.r][move.to.c] = 2;     // New spot has the peg

                // Update game state
                moveCounter++;
                undoStack.push(move);
                selectedPeg = null; // Deselect
                
                renderBoard(); // Re-render the board
                updateUI();    // Update counter and undo button

                // Check for win/loss
                checkGameStatus();
            }

            /**
             * Reverts the last move.
             */
            function handleUndo() {
                if (undoStack.length === 0) return;

                const lastMove = undoStack.pop();

                // Reverse the move
                boardState[lastMove.from.r][lastMove.from.c] = 2; // Put peg back
                boardState[lastMove.over.r][lastMove.over.c] = 2; // Put jumped peg back
                boardState[lastMove.to.r][lastMove.to.c] = 1;     // Empty the target hole

                moveCounter--;
                selectedPeg = null;
                
                renderBoard();
                updateUI();
            }

            /**
             * Clears all 'selected' and 'highlight' classes from the board.
             */
            function clearHighlights() {
                document.querySelectorAll('.peg.selected').forEach(el => el.classList.remove('selected'));
                document.querySelectorAll('.cell-hole.highlight').forEach(el => el.classList.remove('highlight'));
            }

            /**
             * Checks if the game is over (win or loss) and shows the modal.
             */
            function checkGameStatus() {
                let totalPegs = 0;
                let totalValidMoves = 0;

                for (let r = 0; r < 7; r++) {
                    for (let c = 0; c < 7; c++) {
                        if (boardState[r][c] === 2) {
                            totalPegs++;
                            totalValidMoves += findValidMovesForPeg(r, c).length;
                        }
                    }
                }

                if (totalValidMoves === 0) {
                    // Game is over
                    if (totalPegs === 1) {
                        modalTitle.textContent = "You Win!";
                        modalMessage.textContent = "Perfect game! You left only one peg.";
                    } else {
                        modalTitle.textContent = "Game Over!";
                        modalMessage.textContent = `You left ${totalPegs} pegs. Try again!`;
                    }
                    modal.classList.remove('hidden');
                }
            }

            // --- EVENT LISTENERS ---
            resetBtn.addEventListener('click', initGame);
            undoBtn.addEventListener('click', handleUndo);
            playAgainBtn.addEventListener('click', initGame);
            
            // Close modal if clicking outside the content
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.add('hidden');
                }
            });

            // --- START GAME ---
            initGame();
        });
    </script>
</body>
</html>