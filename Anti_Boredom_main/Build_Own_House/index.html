<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D House Builder Editor</title>
<style>
body { margin:0; display:flex; height:100vh; font-family:sans-serif; overflow:hidden; }
#toolbar { width:180px; background:#fff; border-right:2px solid #ccc; padding:10px; display:flex; flex-direction:column; gap:10px; }
.tool { background:#eee; border:1px solid #ccc; padding:10px; text-align:center; cursor:pointer; border-radius:5px; }
.tool:hover { background:#ddd; }
#colorPicker { width:100%; height:30px; border:none; }
#canvas-container { flex:1; position:relative; }
#resetBtn { margin-top:auto; background:#ff4d4d; color:white; padding:10px; border:none; border-radius:5px; cursor:pointer; }
#instructions { font-size:12px; color:#555; margin-top:5px; }
</style>
</head>
<body>

<div id="toolbar">
  <div class="tool" data-type="wall">🧱 Wall</div>
  <div class="tool" data-type="door">🚪 Door</div>
  <div class="tool" data-type="window">🪟 Window</div>
  <div class="tool" data-type="roof">🏠 Roof</div>

  <label>🎨 Color:</label>
  <input type="color" id="colorPicker" value="#ffffff">

  <!-- Instruction text -->
  <p id="instructions">
    Click a tool and then click on the ground to place objects.<br>
    Click an object to move or rotate it.<br>
    Press Ctrl+Z / Cmd+Z to undo the last placed object.
  </p>

  <button id="resetBtn">Reset</button>
</div>

<div id="canvas-container"></div>

<!-- Three.js r127 -->
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r127/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r127/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r127/examples/js/controls/TransformControls.js"></script>

<script>
const container = document.getElementById('canvas-container');
const colorPicker = document.getElementById('colorPicker');
const resetBtn = document.getElementById('resetBtn');

let selectedType = null;
let placedObjects = [];
let selectedObject = null;

// Scene, Camera, Renderer
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xbde0fe);
const camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 1000);
camera.position.set(10,10,10);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

// Lights
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(10,20,10);
scene.add(light);
scene.add(new THREE.AmbientLight(0x888888));

// Ground
const groundGeo = new THREE.PlaneGeometry(50,50);
const groundMat = new THREE.MeshStandardMaterial({color:0x9acd32});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// Controls
const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
orbitControls.enableDamping = true;
orbitControls.dampingFactor = 0.05;
orbitControls.target.set(0,1,0);

// TransformControls for drag & rotate
const transformControls = new THREE.TransformControls(camera, renderer.domElement);
transformControls.addEventListener('change', render);
transformControls.addEventListener('dragging-changed', function (event) {
  orbitControls.enabled = !event.value;
});
scene.add(transformControls);

// Raycaster for object placement & selection
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

renderer.domElement.addEventListener('pointerdown', (event)=>{
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left)/rect.width)*2 - 1;
  mouse.y = -((event.clientY - rect.top)/rect.height)*2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const intersects = raycaster.intersectObjects([...placedObjects, ground]);

  if(intersects.length>0){
    const obj = intersects[0].object;

    if(obj===ground && selectedType){ // Place new object
      addObject(selectedType, intersects[0].point);
    } else if(placedObjects.includes(obj)){ // Select existing object
      selectedObject = obj;
      transformControls.attach(selectedObject);
    }
  } else {
    transformControls.detach();
    selectedObject = null;
  }
});

// Toolbar clicks
document.querySelectorAll('.tool').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    selectedType = btn.dataset.type;
    document.querySelectorAll('.tool').forEach(t=>t.style.background='#eee');
    btn.style.background='#ccc';
  });
});

// Reset button
resetBtn.addEventListener('click', ()=>{
  placedObjects.forEach(obj=>scene.remove(obj));
  placedObjects=[];
  transformControls.detach();
});

// Undo (Ctrl+Z / Cmd+Z)
document.addEventListener('keydown', (event) => {
  if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'z') {
    if (placedObjects.length === 0) return;
    const last = placedObjects.pop();
    scene.remove(last);
    transformControls.detach();
  }
});

// Add object function
function addObject(type, position){
  let geometry, material, mesh;
  const color = new THREE.Color(colorPicker.value);

  switch(type){
    case 'wall': geometry = new THREE.BoxGeometry(3,2,0.2); break;
    case 'door': geometry = new THREE.BoxGeometry(1,2,0.1); break;
    case 'window': geometry = new THREE.BoxGeometry(1.2,1,0.1); break;
    case 'roof': geometry = new THREE.ConeGeometry(2,1,4); break;
  }

  material = new THREE.MeshStandardMaterial({color});
  mesh = new THREE.Mesh(geometry, material);
  mesh.position.copy(position);
  mesh.position.y += (type==='roof'?1.5:1);
  scene.add(mesh);
  placedObjects.push(mesh);
}

// Resize
window.addEventListener('resize', ()=>{
  camera.aspect = container.clientWidth/container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
  render();
});

// Render
function render(){
  renderer.render(scene,camera);
}

// Animate
function animate(){
  requestAnimationFrame(animate);
  orbitControls.update();
  transformControls.update();
  render();
}
animate();
</script>
</body>
</html>
