<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brainvita (Peg Solitaire)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the game */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent; /* Disable tap highlight on mobile */
        }

        .board {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(7, 1fr);
            /* Create a gap that looks like a border */
            gap: 4px;
            background-color: #a0522d; /* Wooden board color */
            border: 8px solid #8b4513; /* Darker wood border */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05), inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
        }

        .cell {
            /* Use aspect-ratio to maintain square shape */
            width: 100%;
            aspect-ratio: 1 / 1;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%; /* Make cells circular */
            background-color: #d2b48c; /* Lighter wood inlay */
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.15s ease-in-out;
        }

        .cell.invalid {
            /* Make invalid cells blend with the board */
            background-color: #a0522d;
            box-shadow: none;
        }

        .cell.empty {
            /* Style for an empty hole */
            background-color: #8b4513; /* Dark hole color */
            box-shadow: inset 0 3px 6px rgba(0,0,0,0.4);
            cursor: pointer;
        }

        .cell .peg {
            /* Style for a peg (marble) */
            width: 75%;
            height: 75%;
            background: radial-gradient(circle at 65% 35%, #ffffff, #f0f0f0 60%, #e0e0e0 100%);
            border-radius: 50%;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2), inset 0 -2px 3px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.15s ease-in-out;
        }

        /* --- Interaction States --- */
        
        .cell .peg.selected {
            /* Highlight for the selected peg */
            transform: scale(1.1);
            box-shadow: 0 0 15px 3px #0ea5e9, 0 4px 8px rgba(0,0,0,0.3), inset 0 -2px 3px rgba(0,0,0,0.1);
        }

        .cell.highlight {
            /* Highlight for a valid move destination */
            background-color: #0ea5e9; /* Bright blue highlight */
            opacity: 0.7;
            box-shadow: inset 0 3px 6px rgba(0,0,0,0.4);
        }

        /* Button styles */
        .btn {
            @apply px-4 py-2 bg-blue-500 text-white rounded-lg shadow-md font-semibold transition-all duration-150 ease-in-out;
        }
        .btn:hover {
            @apply bg-blue-600 shadow-lg;
        }
        .btn:disabled {
            @apply bg-gray-400 cursor-not-allowed opacity-70 shadow-none;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-lg mx-auto">
        <h1 class="text-3xl md:text-4xl font-bold text-center text-gray-800 mb-6">
            Brainvita (Peg Solitaire)
        </h1>

        <!-- Game Controls -->
        <div class="flex justify-between items-center mb-4 px-2">
            <div class="text-lg font-semibold text-gray-700">
                Moves: <span id="move-count" class="font-bold text-blue-600">0</span>
            </div>
            <div class="flex space-x-3">
                <button id="undo-btn" class="btn bg-yellow-400 hover:bg-yellow-500" disabled>Undo</button>
                <button id="reset-btn" class="btn bg-red-400 hover:bg-red-500">Reset</button>
            </div>
        </div>

        <!-- Game Board -->
        <div id="board" class="board w-full rounded-lg p-2">
            <!-- Cells will be generated by JavaScript -->
        </div>
    </div>

    <!-- Message Box (Modal) -->
    <div id="message-box" class="fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm flex items-center justify-center p-4 hidden transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-2xl p-6 md:p-8 w-full max-w-sm text-center">
            <h2 id="message-title" class="text-3xl font-bold mb-4"></h2>
            <p id="message-text" class="text-lg text-gray-700 mb-6"></p>
            <button id="message-close-btn" class="btn w-full">Play Again</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const boardElement = document.getElementById('board');
            const moveCountElement = document.getElementById('move-count');
            const undoBtn = document.getElementById('undo-btn');
            const resetBtn = document.getElementById('reset-btn');
            const messageBox = document.getElementById('message-box');
            const messageTitle = document.getElementById('message-title');
            const messageText = document.getElementById('message-text');
            const messageCloseBtn = document.getElementById('message-close-btn');

            const ROWS = 7;
            const COLS = 7;
            // Board state: -1 = Invalid, 0 = Empty, 1 = Peg
            const initialState = [
                [-1, -1, 1, 1, 1, -1, -1],
                [-1, -1, 1, 1, 1, -1, -1],
                [ 1,  1, 1, 1, 1,  1,  1],
                [ 1,  1, 1, 0, 1,  1,  1],
                [ 1,  1, 1, 1, 1,  1,  1],
                [-1, -1, 1, 1, 1, -1, -1],
                [-1, -1, 1, 1, 1, -1, -1]
            ];

            let boardState = [];
            let moveCount = 0;
            let selectedPeg = null; // { r, c }
            let moveHistory = []; // Stores { from: {r,c}, over: {r,c}, to: {r,c} }

            function initGame() {
                // Deep copy the initial state
                boardState = initialState.map(row => [...row]);
                moveCount = 0;
                selectedPeg = null;
                moveHistory = [];
                updateMoveCount();
                undoBtn.disabled = true;
                messageBox.classList.add('hidden');
                renderBoard();
            }

            function renderBoard() {
                boardElement.innerHTML = '';
                boardState.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        const cellDiv = document.createElement('div');
                        cellDiv.classList.add('cell');
                        cellDiv.dataset.r = r;
                        cellDiv.dataset.c = c;

                        if (cell === -1) {
                            cellDiv.classList.add('invalid');
                        } else if (cell === 0) {
                            cellDiv.classList.add('empty');
                            // Add click listener only to valid cells
                            cellDiv.addEventListener('click', () => onCellClick(r, c));
                        } else if (cell === 1) {
                            const pegDiv = document.createElement('div');
                            pegDiv.classList.add('peg');
                            cellDiv.appendChild(pegDiv);
                            // Add click listener only to valid cells
                            cellDiv.addEventListener('click', () => onCellClick(r, c));
                        }
                        boardElement.appendChild(cellDiv);
                    });
                });
            }

            function onCellClick(r, c) {
                const cellState = boardState[r][c];

                if (cellState === 1) {
                    // Clicked on a peg
                    if (selectedPeg && selectedPeg.r === r && selectedPeg.c === c) {
                        // Deselect the same peg
                        deselectPeg();
                    } else {
                        // Select a new peg
                        selectPeg(r, c);
                    }
                } else if (cellState === 0) {
                    // Clicked on an empty hole
                    if (selectedPeg) {
                        // Check if this is a valid move
                        const move = findValidMove(selectedPeg, { r, c });
                        if (move) {
                            makeMove(move.from, move.over, move.to);
                        } else {
                            // Invalid move, deselect
                            deselectPeg();
                        }
                    }
                }
            }

            function selectPeg(r, c) {
                deselectPeg(); // Clear previous selection
                selectedPeg = { r, c };
                
                // Add visual selection
                const pegElement = boardElement.querySelector(`.cell[data-r="${r}"][data-c="${c}"] .peg`);
                if (pegElement) {
                    pegElement.classList.add('selected');
                }
                
                highlightValidMoves(r, c);
            }

            function deselectPeg() {
                if (selectedPeg) {
                    const pegElement = boardElement.querySelector(`.cell[data-r="${selectedPeg.r}"][data-c="${selectedPeg.c}"] .peg`);
                    if (pegElement) {
                        pegElement.classList.remove('selected');
                    }
                }
                selectedPeg = null;
                
                // Clear all highlights
                document.querySelectorAll('.cell.highlight').forEach(cell => {
                    cell.classList.remove('highlight');
                });
            }

            function findValidMove(from, to) {
                // Check if 'from' is a peg and 'to' is empty
                if (boardState[from.r][from.c] !== 1 || boardState[to.r][to.c] !== 0) {
                    return null;
                }

                const dr = to.r - from.r;
                const dc = to.c - from.c;

                // Check for a 2-space jump horizontally or vertically
                if ((Math.abs(dr) === 2 && dc === 0) || (Math.abs(dc) === 2 && dr === 0)) {
                    const overR = from.r + dr / 2;
                    const overC = from.c + dc / 2;
                    
                    // Check if the "over" cell has a peg
                    if (boardState[overR][overC] === 1) {
                        return { from, over: { r: overR, c: overC }, to };
                    }
                }
                return null;
            }

            function highlightValidMoves(r, c) {
                const directions = [[-2, 0], [2, 0], [0, -2], [0, 2]]; // [dr, dc]
                
                directions.forEach(([dr, dc]) => {
                    const toR = r + dr;
                    const toC = c + dc;
                    
                    // Check if 'to' is within bounds
                    if (toR >= 0 && toR < ROWS && toC >= 0 && toC < COLS) {
                        const move = findValidMove({ r, c }, { r: toR, c: toC });
                        if (move) {
                            const toCell = boardElement.querySelector(`.cell[data-r="${toR}"][data-c="${toC}"]`);
                            if (toCell) {
                                toCell.classList.add('highlight');
                            }
                        }
                    }
                });
            }

            function makeMove(from, over, to) {
                // Update board state
                boardState[from.r][from.c] = 0;
                boardState[over.r][over.c] = 0;
                boardState[to.r][to.c] = 1;

                // Record history
                moveHistory.push({ from, over, to });
                moveCount++;
                
                updateMoveCount();
                undoBtn.disabled = false;
                deselectPeg();
                
                // Re-render the board to reflect the change
                renderBoard();

                // Check for win/loss
                checkGameEnd();
            }

            function undoMove() {
                if (moveHistory.length === 0) return;

                const lastMove = moveHistory.pop();
                const { from, over, to } = lastMove;

                // Reverse the move
                boardState[from.r][from.c] = 1;
                boardState[over.r][over.c] = 1;
                boardState[to.r][to.c] = 0;

                moveCount--;
                updateMoveCount();

                if (moveHistory.length === 0) {
                    undoBtn.disabled = true;
                }
                
                deselectPeg();
                messageBox.classList.add('hidden'); // Hide any end-game messages
                renderBoard();
            }

            function updateMoveCount() {
                moveCountElement.textContent = moveCount;
            }

            function checkGameEnd() {
                let pegCount = 0;
                let possibleMoves = 0;
                const directions = [[-2, 0], [2, 0], [0, -2], [0, 2]];

                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (boardState[r][c] === 1) {
                            pegCount++;
                            // Check for moves from this peg
                            directions.forEach(([dr, dc]) => {
                                const toR = r + dr;
                                const toC = c + dc;
                                if (toR >= 0 && toR < ROWS && toC >= 0 && toC < COLS) {
                                    if (findValidMove({ r, c }, { r: toR, c: toC })) {
                                        possibleMoves++;
                                    }
                                }
                            });
                        }
                    }
                }

                if (pegCount === 1) {
                    // Win condition
                    if (boardState[3][3] === 1) {
                        // Perfect win!
                        showGameMessage("You Win!", "Perfection! You finished with one peg in the center.");
                    } else {
                        // Standard win
                        showGameMessage("You Win!", `Great job! You finished with ${pegCount} peg remaining.`);
                    }
                } else if (possibleMoves === 0) {
                    // Loss condition
                    showGameMessage("Game Over", `No more moves left. You finished with ${pegCount} pegs.`);
                }
            }
            
            function showGameMessage(title, text) {
                messageTitle.textContent = title;
                messageText.textContent = text;
                messageBox.classList.remove('hidden');
            }

            // --- Event Listeners ---
            resetBtn.addEventListener('click', initGame);
            undoBtn.addEventListener('click', undoMove);
            messageCloseBtn.addEventListener('click', initGame); // Play Again button resets game

            // --- Start Game ---
            initGame();
        });
    </script>
</body>
</html>

